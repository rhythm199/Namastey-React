# **Documentation of learning had in this Episode.**

## Q. What is `NPM`?
A: NPM is installed with Node.js. It is also a biggest software package manager and installer. Behind the scene it works as `Node Package Manager` but it doesn't stand for Node Package Manager. NPM is a repository for all the packages. Any package, library, utility we need to import in our project comes with NPM. NPM includes a command-line interface (CLI) used to interact with the online database of NPM. This database is called the NPM Registry, and it hosts public and private 'packages.' To install or update packages, we use the NPM CLI to interact with this database.

All NPM packages are defined in files called package.json. The content of package.json must be written in JSON.
- `npm` alternative is `yarn`
Initialize NPM -
```
npm init
```
It will additionally create `package.json` file but without configurations.

## Q. What is `Parcel/Webpack`? Why do we need it?
A: `Parcel` is a web application bundler comes as node package, used for development and productions purposes or power our application with different type functionalities and features. It offers blazing fast performance utilizing multicore processing, and requires zero configuration. Parcel can take any type of file as an entry point, but an HTML or JavaScript file is a good place to start.

### Parcel Features:
1. Creating a dev build for you
2. Create a local server for you/host app to server
3. Hot Module Replacement (HMR)
4. File watching algorithm
5. Caching while development
6. Image optimization
7. Minification of file
8. Bundling of file
9. Compressing
10. Consistent hashing algorithm
11. Automatic code Splitting
12. Differential Bundling
13. Error Handling
14. Tree Shaking
15. Dev and production bundles
16. Super fast building algorithm
17. HTTPS in dev
18. Port Number
19. Cleaning our code

### Install Parcel using npm:
parcel bundler is required in development phase that's why we install parcel as development dependency(-D).
```
npm install -D parcel 
```

### Building app using parcel:
Parcel has a development server built in, which will automatically rebuild your app as you change files and supports hot module replacement for fast development. Point it at your entry file/entry_point.
* Development build:
    ```
        npx parcel index.html
    ```
* Production build:
    ```
        npx parcel build index.html
    ```

## Q. What is `.parcel-cache`?
A: `.parcel-cache` is a directory generated by the Parcel bundler, serving as a cache for storing intermediate build results. It enhances the development workflow by speeding up subsequent builds and optimizing resource usage. 

## Q: What is `npx`?
A: NPX stands for `Node Package eXecute`. It is simply an NPM package runner. It is a tool that enables you to run packages straight from the NPM registry without installing them globally or locally, maintaining a clean and segregated execution environment. NPX is installed automatically with NPM version 5.2.0 and above.

* Using NPX:
```
npx package-name
```

## Q: What is difference between `dependencies` vs `devDependencies`?
A: `dependencies` are the packages that your project directly depends on to run in production. These packages are necessary for your application to work as intended when it’s deployed or used by end-users. These dependencies are typically things like web frameworks, utility libraries, or other modules(React, Angular, Express) that your code relies on.
To save a dependency as a dependency
```
npm install --save
```

`devDependencies` are packages that are only needed for development and testing purposes, not necessary on production. These packages are not required for your application to function in production, so they are not included when your project is deployed.
Examples: testing libraries, build tools, code linters, and other development-related utilities(parcel, webpack, vite, mocha).
To save a dependency as a devDependency on installation we need to do,
```
npm install --save-dev
```
## Q: What is `Tree Shaking`?
A: `Tree shaking` is a process of eliminating unused code floating around in order to reduce the size of the bundle, and prevent unnecessarily loading more data! . Also called as `dead code elimination` means that unused modules will not be included in the bundle during the build process. This is important for preparing code that is production ready, for example with clean structures and minimal file size.

It relies on the import and export statements to detect if code modules are exported and imported for use between JavaScript files. Tools like webpack will detect dead code and mark it as “unused module” but it won’t remove the code. Webpack relies on `minifiers` to cleanup dead code from the bundle to make our application more optimized.

## Q: What is `Hot Module Replacement`?
A: `Hot Module Replacement` (HMR) is a powerful feature designed to enhance the development process by providing real-time updates to modules (like adding, removing or updating) within a running application without requiring a full page reload, thereby saving valuable time during development. HMR uses File Watcher algorithms to keep track of file changes while development and renders those changes on the Web UI.

* The application state is retained which is usually lost during full reload
* Instantly updates the browser when source css/js code is modified.

## Q: List down your favorite 5 superpowers of Parcel and
* `Minification` - Minification is the process of minimizing code and markup in your web pages and script files.
* `Image optimization` - By default, Parcel includes lossless image optimization for JPEGs and PNGs in prod. mode, which reduces the size of images without affecting their quality. No configuration or query parameters are required to use.
* `HMR (Hot Module Replacement)` - adds, or removes modules while an application is running, without a full reload.
* `File watcher algorithm` - File Watchers monitor directories on the file system and perform specific actions when desired files appear. When changes are detected, such as modifications, additions, or deletions of files, the file watching algorithm triggers an action.
* `Caching while development` -  Parcel caches everything it builds. On restart the dev server, Parcel will only rebuild files that have changed since the last time it ran. Parcel automatically tracks all of the files, configuration, plugins, and dev dependencies that are involved in your build

## Q: What is `.gitignore`? What should we add and not add into it?
A: `.gitignore` file is a text file where we can mention the files/directories to ignore. That is, those files/directories will not be pushed into the git repositories. The great advantage of putting them in .gitignore file is that those can be huge in size and those files can be generated with the help of package.json or package-lock.json file. It's very important to put node_modules in the .gitignore file since it contains a lot of packages which can be installed later by using package.json file. Other directories that should be placed in .gitignore file are .parcel-cache and dist. package.json and package-lock.json must not be put in .gitignore file.


## Q: What is the difference between `package.json` and `package-lock.json`?
Both files are essential for managing dependencies, but they serve different purposes in the Node.js development workflow. This files must not be put in .gitignore file and must be pushed to github to typically tracked in version control systems like Git and serves as a shared configuration file.
| package.json    | package-lock.json    | 
| ------------    | -------------        |
|This file is created as soon as npm init command is fired.|This file is generated and updated automatically by npm when installing or updating packages. |
|This file is primarily used for managing and documenting metadata about the project, including its name, version, author, dependencies, scripts, and other configuration details.| It is used to lock the exact versions of dependencies installed in the project, ensuring reproducibility and consistent installations across different environments.|
|It contains only direct dependencies|It contains nested/transitive dependencies (dependencies of dependencies)|
|During deployment, there is no guarantee that if the version number of the dependencies with which the project was developed (package.json file has the least version of dependencies), will be reproduced and thus the project might not be working as intended.|During deployment, the exact version of dependencies will be reproduced and thus the project will be working as intended.|
|^ or ~ can be used in version of dependencies in package.json|Only exact version of dependencies must be used in package-lock.json|
|Developers manually edit this file to add or remove dependencies, modify scripts, update version ranges, or make other configuration changes.|It is generally not meant to be manually edited, as it is managed automatically by npm. Manual changes to this file can lead to inconsistencies or conflicts in dependency resolution.|
|It is typically tracked in version control systems like Git and serves as a shared configuration file among project contributors.|It is also tracked in version control systems to ensure consistent dependency installations across different development environments.|

* **~** : `Approximately equivalent to version`, will update you to all future patch versions, without incrementing the minor version.
* **^** : `Compatible with version`, will update you to all future minor/patch versions, without incrementing the major version.

> If none of them is present, that means only the version specified in `package.json` file is used in the development.


## Q: Why should I not modify package-lock.json?
A: `package-lock.json` file ensures deterministic installations by locking the exact versions of dependencies and their dependencies versions. It is not meant to be manually edited, as it is managed automatically by npm.Having contains the entire tree of dependencies, manual changes to this file can lead to inconsistencies or conflicts in dependency issues in the production environment.

## Q: What is `node_modules`? Is it a good idea to push that on git?
A: The `node_modules` folder is a folder that is created when you install packages using the `Node Package Manager`(NPM). It stores the packages and their dependencies that your project requires used the the development of the application. node_modules holds the source code of the packages that are installed through npm.

In git, the node_modules folder is typically included in the `.gitignore` file, a configuration file that tells git which files and directories to ignore when committing changes to a repository. This is done because the node_modules folder can be very large, and tracking changes to the packages and dependencies in your Git repository is usually unnecessary.

If you want to include the node_modules folder in your Git repository, you can remove it from the .gitignore file. However, this is generally not recommended, as it can lead to large repository sizes and slower performance. Instead, it is typically better to track your project's dependencies using a package.json file, which lists the packages and their versions that your project requires. This allows you to recreate the node_modules folder and install the required packages by running npm install whenever you clone or update your repository.

## Q: What is the `dist` folder?
A: The `/dist` stands for distributable. This folder contains the minimized version of the source code. The code present inside it is actually the code which is used on production web applications. Along with the minified code, the /dist folder also comprises of all the compiled modules that may or may not be used with other systems.

/dist folder is created when parcel creates the build for the application. IT contains the output of the bundler i.e all js files, css files and html files bundled into a single js file, css file and html file that is compressed and minified.

## Q: What is `browserslist`?
A: `browserslist` is a tool that allows specifying which browsers should be supported in your frontend app by specifying "queries" in a config file. It also covers the browser coverage over a geographical area. It's used by frameworks/libraries such as React, Angular and Vue, but it's not limited to them.

The value of this object can be an array of statistics ( % coverage), last versions, Node.js versions, Browser versions or even unreleased versions.
```
"browsersList" : ["last 2 versions", "> 1%", "not dead"]
```
## Q: Read about: ^ - `caret` and ~ - `tilda`
A: The tilde (~) and caret (^) symbols are both used in the package.json file to specify version ranges for package dependencies.

The difference between them is how they define the range of compatible versions:
|`^` - caret|`~` - tilda|
|-----------|-----------|
|The caret (^) symbol specifies a “compatible with most recent” version range that includes all minor updates (the second number) and patch updates, but not major updates.|The tilde (~) symbol specifies a range of compatible versions that includes all patch updates (the third number in the version string) but not minor updates (the second number) or major updates (the first number).|
|This means that you’re willing to accept any version of the package that is compatible with the version you specify, as long as it doesn’t break compatibility with the major version.|This means that you’re willing to accept any version of the package that is compatible with the version you specify.|
|For example, "^1.2.3" would include versions 1.2.3, 1.3.0, 1.4.0, but not 2.0.0.|For example, "~1.2.3" would include versions 1.2.3, 1.2.4, 1.2.5, but not 1.3.0 or 2.0.0.|
|This allows us to receive patches, bug fixes, and minor version changes, but not major version changes.|This allows us to receive patches and bug fixes, but not minor or major version changes.|